// Внимание! Хедер еще не закончен. К выполнению не приступать
#ifndef __TRIU7_H__
#define __TRIU7_H__

#define     IU7_TRUE            1
#define     IU7_FALSE           0
#define     IU7_SUCCESS         0
#define     IU7_FAIL            -1
#define     IU7_WRONG_TREE      -2
#define     IU7_WRONG_INDEX     -3

// Корнень -- изначальный узел дерева
// Остальные указатели на узлы 
// объявлять как "triu7_node"
// Пользователь должен иметь дело
// только с типом rooiu7t
typedef struct triu7 triu7; // узел дерева
typedef triu7 *rooiu7t; // корень дерева
typedef triu7 *triu7_node; // узел дерева




/*  Структура узла дерева   */
/****************************/
// Содержание структуры:
// 1. Указатель на универсальную информацию.
//
// 2. Массив весов связей с "детьми" узла. 
// (берется реализация 1-го семинара)
//
// 3. Список листьев.
// (берется реализация 4-го семинара)
//
// Внимание:
// --> Изначальный узел дерева и является корнем. (см. тип на строке 17)
// За счет этого корень можно будет легко поменять.
// --> Связь узлов двунаправленная: если в leaves первого узла
// имеется указатель на второй узел, то у второго узла
// будет аналогичный указатель на первый (с весом связей
// аналогично).
struct triu7
{
    void *data;
    darriu7 *con_pow; // == connection power
    liu7st leavs; 
};


/*  Создание дерева  */
/*********************/
// Реализуют: Коновалова, Неклепаева
// Вход - указатель на данные корня
// Выход - указатель на первый корень
// Особенность: при нежелании добавлять
// что-либо в data пользователь передает 
// NULL.
rooiu7t triu7_create(void *data);


/*  Освобождение памяти из-под дерева  */
/***************************************/
// Реализуют: Ильясов, Игнатьев
// Вход: указатель на дерево
// Особенность: NULL на входе обрабатывается корректно.
void triu7_free(rooiu7t root);


/*  Проверка на наличие цикла  */
/*******************************/
// Реализуют: Пудов, Грунковский
// Вход: корень дерева
// Выход: IU7_TRUE, если цикл был найден,
// IU7_FALSE иначе. Остальные ошибки обсуждать
// с гит-мастером.
int triu7_has_cycle(rooiu7t root);


/*  Применение функции func ко всей информации дерева  */
/*******************************************************/
// Реализуют: Дроздов, Степанов
// Вход: корень дерева
//       указатель на func
// Выход: IU7_SUCCESS в случае удачного завершения программы,
// IU7_FAIL иначе
int triu7_dat_apply(rooiu7t root, void (*func)(void *data));

/*  Применение функции func ко всем листьям дерева  */
/*******************************************************/
// Реализуют: ?
// Вход: корень дерева
//       указатель на func
// Выход: IU7_SUCCESS в случае удачного завершения программы,
// IU7_FAIL иначе
int triu7_dat_apply(rooiu7t root, void (*func)(void *data));


/*  Применение ф-ии критерия ко всей информации дерева  */
/********************************************************/
// Реализуют: ?
// Вход : корень дерева
//        функция-критерий "test"
//        переменная накопления "статистики" out
// Выход: IU7_SUCCESS в случае удачного завершения программы,
// IU7_FAIL иначе 
int triu7_dat_test(rooiu7t root, int (*test)(void *data, int *out), int *out);


/*  Нахождения количества элементов в дереве  */
/**********************************************/
// Реализуют: Мороз, Москаленко
// Вход: корень дерева
// Выход: код ошибки (<0) при ошибочных данных,
// размер дерева иначе
int triu7_size(rooiu7t root); // Не забудьте проверить древо на наличие цикла!


/*  Нахождение максимальной глубины дерева  */
/********************************************/
// Реализуют: Горбунов
// Вход: корень дерева
// Выход: код ошибки (<0) при ошибочных данных,
// размер дерева иначе
int triu7_depth(rooiu7t root); // Не забудьте проверить древо на наличие цикла!

/*  Вывод дерева  */
/******************/
// Реалирует Степанов
// Вход: корень
// Выход: "решается"


#endif // __TRIU7_H__




    
