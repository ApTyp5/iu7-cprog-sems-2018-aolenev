// Внимание! Хедер еще не закончен. К выполнению не приступать
#ifndef __TRIU7_H__
#define __TRIU7_H__

#define     IU7_TRUE            1
#define     IU7_FALSE           0
#define     IU7_SUCCESS         0
#define     IU7_FAIL            -1
#define     IU7_WRONG_TREE      -2
#define     IU7_WRONG_INDEX     -3


/*  Структура узла дерева   */
/****************************/
// Содержание структуры:
// 1. Указатель на универсальную информацию.
//
// 2. Массив весов связей с "детьми" узла. 
// (берется реализация 1-го семинара)
//
// 3. Список листьев.
// (берется реализация 4-го семинара)
//
// Внимание:
// --> Изначальный узел дерева и является корнем.
// За счет этого корень можно будет легко поменять.
// --> Связь узлов двунаправленная: если в leaves первого узла
// имеется указатель на второй узел, то у второго узла
// будет аналогичный указатель на первый (с весом связей
// аналогично).

typedef struct triu7_node triu7_node;
typedef triu7_node *triu7;

struct triu7_node
{
    void *data;
    darriu7 *con_wei; // == connection weight
    liu7st leavs; 
};


/*  Создание дерева  */
/*********************/
// Реализуют: Коновалова, Неклепаева
// Вход - указатель на данные корня
// Выход - указатель на первый корень
// Особенность: при нежелании добавлять
// что-либо в data пользователь передает 
// NULL
triu7 triu7_create(void *data);


/*  Освобождение памяти из-под дерева  */
/***************************************/
// Реализуют: Ильясов, Игнатьев
// Вход: указатель на корень
// Особенность: NULL на входе обрабатывается корректно
void triu7_free(triu7 root);

/*  Добавление листа  */
/**********************/
// Реализуют: ?
// Вход : указатель на корень, куда добавляется лист
//        указатель на data добавляемого листа
//        вес связи корня с добавляемым листом
// Выход: код состояния
int triu7_add(triu7 root, void *new_data, int weight);


/*  Добавление поддерева  */
/**************************/
// Реализуют: ?
// Вход : указатель на корень (куда добавляют)
//        указатель на подкорень (который добавляют)
// Выход: код состояния
int triu7_add_subtree(triu7 root, triu7 subroot);



/*  Проверка на наличие цикла  */
/*******************************/
// Реализуют: Пудов, Грунковский
// Вход: корень дерева
// Выход: IU7_TRUE, если цикл был найден,
// IU7_FALSE иначе. Остальные ошибки обсуждать
// с гит-мастером
int triu7_has_cycle(triu7 root);


/*  Применение функции func ко всей информации дерева  */
/*******************************************************/
// Реализуют: Дроздов, Степанов
// Вход: корень дерева
//       указатель на func
// Выход: код состояния
int triu7_dat_apply(triu7 root, void (*func)(void *data));


/*  Сортировка листьев по возрастанию  */
/*******************************************************/
// Реализуют: ?
// Вход:  корень дерева
// Выход: код состояния
int triu7_leav_sort(triu7 root);


/*  Применение ф-ии критерия ко всей информации дерева  */
/********************************************************/
// Реализуют: ?
// Вход : корень дерева
//        функция-критерий "test"
//        переменная накопления "статистики" out
// Выход: код состояния
int triu7_dat_test(triu7 root, int (*test)(void *data, int *out), int *out);


/*  Нахождения количества элементов в дереве  */
/**********************************************/
// Реализуют: Мороз, Москаленко
// Вход: корень дерева
// Выход: код состояния (<0) при ошибочных данных,
// размер дерева иначе
int triu7_size(triu7 root); // Не забудьте проверить древо на наличие цикла!


/*  Нахождение максимальной глубины дерева  */
/********************************************/
// Реализуют: Горбунов
// Вход: корень дерева
// Выход: код состояния (<0) при ошибочных данных,
// размер дерева иначе
int triu7_depth(triu7 root); // Не забудьте проверить древо на наличие цикла!


#endif // __TRIU7_H__




    
