#ifndef __TRIU7_H__
#define __TRIU7_H__

#include "../sem_01_vector/darriu7.h"
#include "../sem_04_liu7st/liu7st.h"

#define     IU7_TRUE            1
#define     IU7_FALSE           0
#define     IU7_SUCCESS         0
#define     IU7_FAIL            -1
#define     IU7_WRONG_TREE      -2
#define     IU7_WRONG_INDEX     -3


typedef struct triu7_node triu7_node;
typedef triu7_node *triu7_ptr;


/**
 * \struct узел дерева
 * \param указатель на информацию
 * \param динамический массив весов связей
 * \param список потомков данного узла
 *
 * i-ый элемент массива обозначает вес связи с i-ым
 * потомком. Поэтому в массиве и списке всегда будет 
 * одинаковое число элементов
 */
struct triu7_node
{
    void *data;
    darriu7 con_wei; // == connection weight
    liu7st *leavs; 
};


/**
 * \brief Создание дерева
 * \param [in] Указатель на информацию, соответствующую данному узлу
 *
 * \authors Неклепаева, Коновалова
 *
 * \warning Если пользователь не хочет сопоставлять с данным узлом
 * какую-либо информацию, то на вход подается NULL
 */
triu7_ptr triu7_create(void *data);


/**
 * \brief Освобождение памяти из-под дерева
 * \param [in] двойной указател на корень дерева
 *
 * \authors Игнатьев, Ильясов
 * 
 * NULL обрабатывается корректно
 *
 * \warning в ф-ю передается двойной указатель,
 * чтобы присвоить освобожденному указателю значение
 * NULL, что будте являться критерием корректности 
 * освобождения
 */
void triu7_free(triu7_ptr *root);

/**
 * \brief Добавление листа к узлу
 * \param [in] node указатель на нужный узел
 * \param [in] new_data указатель на информацию, которую 
 * пользователь хочет сопоставить с этим узлом
 * \param [in] weight вес связи добавляемого узла
 *
 * \authors Дроздов
 *
 * \return код состояния программы
 */
int triu7_add(triu7_ptr node, void *new_data, int weight);


/** 
 * \brief Добавление поддерева к узлу
 * \param [in] node указатель на узел, к которому прикрепляется поддерево
 * \param [in] subroot указатель на корень добавляемого поддерева
 * \param [in] weight вес связи
 *
 * \authors Игнатьев
 *
 * \return код сотояния программы
 */
int triu7_add_subtree(triu7_ptr node, triu7_ptr subroot, int weight);



/**
 * \brief Проверка на наличие цикла
 * \param [in] указатель на узел, который вместе
 * с его потомками будет проверен на наличие цикла
 *
 * \authors Пудов Грунковский
 *
 * \return код состояния
 */
int triu7_has_cycle(triu7_ptr node);


/**
 * \brief применение ф-ии ко всей информации дерева
 * \param [in] указатель на узел, к потомкам которого будет 
 * применена ф-я
 * \param [in] указатель на ф-ю, которую надо применить к
 * информации, на которую указывают узлы
 *
 * \authors Степанов, Дроздов
 *
 * \return код сотояния
 */
int triu7_dat_apply(triu7_ptr node, void (*func)(void *data));


/**
 * \brief нахождение кол-ва элементов в дереве
 * \param [in] указатель на узел дерева
 * 
 * \authors Мороз, Москаленко
 *
 * \return код сотояния
 */ 
int triu7_size(triu7_ptr node); 


/*  Нахождение максимальной глубины дерева  */
/********************************************/
// Реализуют: Горбунов
// Вход: узел дерева
// Выход: код состояния (<0) при ошибочных данных,
// размер дерева иначе
int triu7_depth(triu7_ptr node); 



/**
 * \brief печать дерева
 *
 * \param [in] node указатель на узел дерева,
 * который будет напечатан вместе с его потомками
 * \param [in] pdata ф-я печати данных
 * 
 * \author Степанов
 *
 * \return код состояния программы
 *
 * От родительского элемента идут стрелки к дочерним,
 * каждое поддерево печатается с дополнительным отступом
 *
 * Пример(дерево представлю в виде массива, каждый элемент хранит номер позиции отца,
 *     корень - нулевой элемент не имеет отца и хранит значение -1):
 *
 * arr: -1 0 0 0 1 1 2 3 3 3 8
 * выведется это так:
 * data(arr[0])
 * ├─>data(arr[1])
 * │  ├─>data(arr[4])
 * │  └─>data(arr[5])
 * ├─>data(arr[2])
 * │  └─>data(arr[6])
 * └─>data(arr[3])
 *    ├─>data(arr[7])
 *    ├─>data(arr[8])
 *    │  └─>data(arr[10])
 *    └─>data(arr[9])
 *
 * \warning ф-я pdata нужна для того, чтобы печатать инфу, на которую указывает узел в одну строку
 */
int triu7_print(triu7_ptr node, void (* pdata)(void *));


#endif // __TRIU7_H__

